/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	var error_graph, init_graph;
	
	$(document).ready(function() {
	  var global_gui, imports, message, session, uivent;
	  imports = {
	    ui: __webpack_require__(1),
	    connect: __webpack_require__(3),
	    data: __webpack_require__(4),
	    messages: __webpack_require__(6),
	    settings: __webpack_require__(2)
	  };
	  message = new imports.messages.SessionDisconnectedMessage({
	    el: imports.settings.id.globalmessages
	  });
	  message.show();
	  uivent = new imports.ui.Vent();
	  uivent.register({
	    'ui': imports.ui
	  });
	  global_gui = new imports.ui.GlobalGUI();
	  session = new imports.connect.Session(config.sessions_endpoint);
	  session.connect_metabook(config.file.path);
	  return imports.data.get_xhr(config.file.endpoint + config.file.path).done(function(file_json) {
	    return init_graph(file_json);
	  }).fail(error_graph);
	});
	
	init_graph = function(json_graph) {
	  var menuview, notebook, paper;
	  notebook = new metabook.models.MetabookModel({}, {
	    json_graph: json_graph
	  });
	  paper = init_jointjs(notebook);
	  notebook.session = new metabook.connect.Session(config.sessions_endpoint, notebook.id);
	  $("#id2").dimmer('hide');
	  $("#bottom_sidebar").sidebar({
	    context: $('#id2')
	  });
	  $("#bottom_sidebar").sidebar('setting', 'transition', 'overlay');
	  $("#bottom_sidebar").sidebar('setting', 'dimPage', false);
	  $("#bottom_sidebar").sidebar('attach events', '#uiMenuToggle');
	  $("#bottom_sidebar").sidebar('setting', 'closable', false);
	  uivent.register({
	    'session': notebook.session,
	    'model': notebook,
	    'graph': paper.model
	  });
	  jointjs_attach_events(paper, paper.model);
	  return menuview = new metabook.views.MenuView({
	    el: $("#metabook_top_menu"),
	    model: notebook
	  });
	};
	
	error_graph = function(e) {
	  $("#id2").dimmer('hide');
	  return alert("Connection error. Check if your backend is running.");
	};
	
	//# sourceMappingURL=init.js.map


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	var ContextMenu, ContextMenuView, GlobalGUI, Settings, Vent, bind_context_menus, custom_events, settings,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	Settings = __webpack_require__(2);
	
	settings = {
	  active_menu_class: "context-menu--active",
	  selector: "#context-menu",
	  context_bindings: {
	    ".element": "#context-menu",
	    "svg": "#context-menu2"
	  },
	  templates: {
	    node: "<a href=\"#\" class=\"item\" data-action=\"graph:node:properties\"><i class=\"fa fa-tasks\"></i> Properties <div class=\"ui small inverted label\">Ctrl+Enter</div></a>\n<a href=\"#\" class=\"item\" data-action=\"session:run\"><i class=\"fa fa-play\"></i> Run Node <div class=\"ui small inverted label\">Ctrl+E</div></a>\n<a href=\"#\" class=\"item\" data-action=\"graph:node:update\"><i class=\"fa fa-exchange\"></i> Sync to Server <div class=\"ui small inverted label\">Ctrl+D</div></a>\n<a href=\"#\" class=\"item\" data-action=\"graph:node:expand\"><i class=\"fa fa-expand\"></i> Expand & Edit <div class=\"ui small inverted label\">Ctrl+D</div></a>\n<a href=\"#\" class=\"item\" data-action=\"graph:node:duplicate\"><i class=\"fa fa-copy\"></i> Duplicate <div class=\"ui small inverted label\">Ctrl+D</div></a>\n<a href=\"#\" class=\"item\" data-action=\"graph:node:similar\"><i class=\"fa fa-plus\"></i> Select Similar <div class=\"ui small inverted label\">Ctrl+D</div></a>\n<a href=\"#\" class=\"item\" data-action=\"graph:node:delete\"><i class=\"fa fa-times\"></i> Delete <div class=\"ui small inverted label\">Ctrl+D</div></a>",
	    blank: "<a href=\"#\" class=\"item\" data-action=\"graph:newnode\"><i class=\"fa fa-eye\"></i> New node <div class=\"ui small inverted label\">Ctrl+D</div></a>\n<a href=\"#\" class=\"item\" data-action=\"model:solve\"><i class=\"fa fa-edit\"></i> Run <div class=\"ui small inverted label\">Ctrl+E</div></a>\n<a href=\"#\" class=\"item\" data-action=\"graph:node:delete\"><i class=\"fa fa-times\"></i> Delete <div class=\"ui small inverted label\">Ctrl+D</div></a>"
	  }
	};
	
	bind_context_menus = function() {
	  var menu_id, ref, results, selector;
	  ref = settings.context_bindings;
	  results = [];
	  for (selector in ref) {
	    menu_id = ref[selector];
	    results.push(this.context_listener.apply(this, [selector, menu_id]));
	  }
	  return results;
	};
	
	custom_events = {
	  'add': function(cell) {
	    return cell.$box.on('contextmenu', _.partialRight(function(e, cell) {
	      var menu;
	      e.preventDefault();
	      return menu = new ContextMenuView(cell.model, {
	        cell: cell,
	        event: e,
	        "class": settings.active_menu_class,
	        selector: settings.selector,
	        template: settings.templates.node
	      });
	    }, cell));
	  },
	  'blankmenu': function(paper, e) {
	    var menu;
	    e.preventDefault();
	    return menu = new ContextMenuView(paper.model, {
	      event: e,
	      "class": settings.active_menu_class,
	      selector: settings.selector,
	      template: settings.templates.blank
	    });
	  }
	};
	
	GlobalGUI = (function(superClass) {
	  extend(GlobalGUI, superClass);
	
	  function GlobalGUI() {
	    return GlobalGUI.__super__.constructor.apply(this, arguments);
	  }
	
	  GlobalGUI.prototype.initialize = function() {
	    this.listenTo(Backbone, 'graph:notready', this.dim);
	    return this.listenTo(Backbone, 'graph:ready', this.undim);
	  };
	
	  GlobalGUI.prototype.dim = function() {
	    return $("#id2").dimmer({
	      closable: false
	    }).dimmer('show');
	  };
	
	  GlobalGUI.prototype.undim = function() {
	    return $("#id2").dimmer('hide');
	  };
	
	  return GlobalGUI;
	
	})(Backbone.View);
	
	ContextMenuView = (function(superClass) {
	  extend(ContextMenuView, superClass);
	
	  function ContextMenuView() {
	    this.getPosition = bind(this.getPosition, this);
	    this.position_active_menu = bind(this.position_active_menu, this);
	    this.hide = bind(this.hide, this);
	    return ContextMenuView.__super__.constructor.apply(this, arguments);
	  }
	
	  ContextMenuView.prototype.initialize = function(model, settings) {
	    this.active_menu_class = settings["class"];
	    this.template = settings.template;
	    this.el = $(settings.selector);
	    this.event = settings.event;
	    this.model = model;
	    this.cell = settings.cell;
	    Backbone.View.prototype.initialize.apply(this, arguments);
	    return this.render();
	  };
	
	  ContextMenuView.prototype.render = function() {
	    this.el.html(this.template);
	    this.el.addClass(this.active_menu_class);
	    this.position_active_menu(this.event);
	    document.addEventListener("click", this.hide);
	    $(Settings.id.paper).on('mousewheel', this.hide);
	    window.onresize = this.hide;
	    window.onkeyup = (function(_this) {
	      return function(e) {
	        if (e.keyCode === 27) {
	          return _this.hide();
	        }
	      };
	    })(this);
	    return this.el.on("click [data-action]", (function(_this) {
	      return function(ev) {
	        var custom_event;
	        _this.el.off('click [data-action]');
	        custom_event = ev.target.dataset.action;
	        Vent.vent(custom_event, _this.model, ev);
	        console.log(custom_event + " element event triggered");
	        return _this.hide();
	      };
	    })(this));
	  };
	
	  ContextMenuView.prototype.hide = function() {
	    this.el.removeClass(this.active_menu_class);
	    this.remove();
	    return this.unbind();
	  };
	
	  ContextMenuView.prototype.position_active_menu = function(e) {
	    var menuHeight, menuWidth, ref, windowHeight, windowWidth, x, y;
	    ref = this.getPosition(e), x = ref.x, y = ref.y;
	    menuWidth = this.el.offsetWidth + 4;
	    menuHeight = this.el.offsetHeight + 4;
	    windowWidth = window.innerWidth;
	    windowHeight = window.innerHeight;
	    if (windowWidth - x < menuWidth) {
	      this.el.css('left', windowWidth - menuWidth + 'px');
	    } else {
	      this.el.css('left', x + 'px');
	    }
	    if (windowHeight - y < menuHeight) {
	      this.el.css('top', windowHeight - menuHeight + 'px');
	    } else {
	      this.el.css('top', y + 'px');
	    }
	  };
	
	  ContextMenuView.prototype.getPosition = function(e) {
	    var posx, posy;
	    posx = 0;
	    posy = 0;
	    if (e == null) {
	      e = window.event;
	    }
	    if (e.pageX) {
	      posx = e.pageX;
	      posy = e.pageY;
	    } else {
	      posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
	      posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
	    }
	    return {
	      x: posx,
	      y: posy - 12
	    };
	  };
	
	  return ContextMenuView;
	
	})(Backbone.View);
	
	ContextMenu = {
	
	  /*
	  Usage:
	  selector is the element to bind menu to
	  menu_id is the id of menu div that is being bound to selector
	  settings.context_menu = { str selector: str menu_id, ... }
	   */
	  active_menu_class: "context-menu--active",
	  active_menu: void 0,
	  init: function(settings) {
	    var context, menu_id, selector;
	    this.active_menu_class = settings.active_menu_class || this.active_menu_class;
	    context = settings.context_menu;
	    this.active_menu = void 0;
	    for (selector in context) {
	      menu_id = context[selector];
	      this.context_listener.apply(this, [selector, menu_id]);
	    }
	    this.clickListener();
	    this.keyupListener();
	    this.resizeListener();
	    this.scrollListener();
	  },
	  context_listener: function(selector, menu_id) {
	    $(selector).on('contextmenu', function(e) {
	      e.preventDefault();
	      if (ContextMenu.active_menu) {
	        ContextMenu.active_menu_off();
	      }
	      ContextMenu.menu_on(menu_id);
	      ContextMenu.position_active_menu(e);
	      return e.stopPropagation();
	    });
	  },
	  active_menu_off: function() {
	    if (ContextMenu.active_menu) {
	      ContextMenu.active_menu.classList.remove(ContextMenu.active_menu_class);
	      ContextMenu.active_menu = void 0;
	    }
	  },
	  menu_on: function(menu_id) {
	    ContextMenu.active_menu = document.querySelector(menu_id);
	    ContextMenu.active_menu.classList.add(ContextMenu.active_menu_class);
	  },
	  position_active_menu: function(e) {
	    var menuHeight, menuWidth, ref, windowHeight, windowWidth, x, y;
	    ref = ContextMenu.getPosition(e), x = ref.x, y = ref.y;
	    menuWidth = ContextMenu.active_menu.offsetWidth + 4;
	    menuHeight = ContextMenu.active_menu.offsetHeight + 4;
	    windowWidth = window.innerWidth;
	    windowHeight = window.innerHeight;
	    if (windowWidth - x < menuWidth) {
	      ContextMenu.active_menu.style.left = windowWidth - menuWidth + 'px';
	    } else {
	      ContextMenu.active_menu.style.left = x + 'px';
	    }
	    if (windowHeight - y < menuHeight) {
	      ContextMenu.active_menu.style.top = windowHeight - menuHeight + 'px';
	    } else {
	      ContextMenu.active_menu.style.top = y + 'px';
	    }
	  },
	  getPosition: function(e) {
	    var posx, posy;
	    posx = 0;
	    posy = 0;
	    if (e == null) {
	      e = window.event;
	    }
	    if (e.pageX) {
	      posx = e.pageX;
	      posy = e.pageY;
	    } else {
	      posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
	      posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
	    }
	    return {
	      x: posx,
	      y: posy - 12
	    };
	  },
	  clickListener: function() {
	    return document.addEventListener("click", function(e) {
	      ContextMenu.active_menu_off();
	    });
	  },
	  keyupListener: function() {
	    window.onkeyup = function(e) {
	      if (e.keyCode === 27) {
	        ContextMenu.active_menu_off();
	      }
	    };
	  },
	  resizeListener: function() {
	    window.onresize = function(e) {
	      ContextMenu.active_menu_off();
	    };
	  },
	  scrollListener: function() {
	    $('#myholder').on('mousewheel', function(e) {
	      ContextMenu.active_menu_off();
	    });
	  }
	};
	
	Vent = (function() {
	  function Vent() {
	    _.extend(this, Backbone.Events);
	  }
	
	  Vent.prototype.register = function(handlers) {
	    var event_handler, eventclass, eventname, handler, results;
	    results = [];
	    for (eventclass in handlers) {
	      handler = handlers[eventclass];
	      results.push((function() {
	        var ref, results1;
	        ref = handler['custom_events'];
	        results1 = [];
	        for (eventname in ref) {
	          event_handler = ref[eventname];
	          results1.push(this.listenTo(Backbone, eventclass + ":" + eventname, _.bind(event_handler, handler)));
	        }
	        return results1;
	      }).call(this));
	    }
	    return results;
	  };
	
	  Vent.vent = function(custom_event) {
	    var args, primary, secondary, tokens;
	    tokens = custom_event.split(':');
	    primary = tokens.slice(0, 2).join(':');
	    secondary = tokens.slice(2).join(':');
	    args = [].slice.call(arguments, 1);
	    if (secondary !== "") {
	      args.unshift(secondary);
	    }
	    args.unshift(primary);
	    return Backbone.trigger.apply(Backbone, args);
	  };
	
	  Vent.passover = function() {
	    var args, event_name, obj;
	    args = [].slice.call(arguments, 2);
	    event_name = arguments[0];
	    obj = arguments[1];
	    return obj.custom_events[event_name].apply(obj, args);
	  };
	
	  return Vent;
	
	})();
	
	module.exports = {
	  bind_context_menus: bind_context_menus,
	  custom_events: custom_events,
	  ContextMenuView: ContextMenuView,
	  ContextMenu: ContextMenu,
	  Vent: Vent,
	  GlobalGUI: GlobalGUI
	};
	
	//# sourceMappingURL=ui.js.map


/***/ },
/* 2 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0
	module.exports = {
	  id: {
	    messages: "#messages",
	    coords: "#coords",
	    graph_container: "#paper_holder",
	    paper: "#myholder",
	    svg: "#v-2",
	    globalmessages: "#globalmessages"
	  }
	};
	
	//# sourceMappingURL=settings.js.map


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	var Message, Session, imports;
	
	imports = {
	  data: __webpack_require__(4),
	  websocket: __webpack_require__(5)
	};
	
	Session = (function() {
	  function Session(url) {
	    this.id = joint.util.uuid();
	    this.ws = new imports.websocket("ws://" + url + this.id, null, {
	      debug: true,
	      reconnectInterval: 1000,
	      maxReconnectInterval: 30000,
	      reconnectDecay: 1.5
	    });
	    this.ws.onopen = this.onopen;
	    this.ws.onmessage = this.onmessage;
	    this.ws.onclose = this.onclose;
	  }
	
	  Session.prototype.onopen = function(evt) {
	    return console.log('<connection onopen>');
	  };
	
	  Session.prototype.connect_notebook = function(local_path) {
	    var msg;
	    msg = this.new_message({
	      type: 'connect notebook'
	    });
	    return this.ws.send(msg.serialize());
	  };
	
	  Session.prototype.new_message = function(arg) {
	    var content, type;
	    type = arg.type, content = arg.content;
	    return new Message({
	      session: this.id,
	      msg_type: type,
	      content: content
	    });
	  };
	
	  Session.prototype.run_cell = function(node_model, event) {
	    var cells, ids, links, msg;
	    cells = importsimports.data.get_cells(node_model.graph.metabook);
	    links = importsimports.data.get_links(node_model.graph.metabook);
	    ids = [node_model.id];
	    msg = new Message({
	      session: this.id,
	      msg_type: "update",
	      content: {
	        cells: cells,
	        links: links,
	        ids: ids
	      }
	    });
	    return this.ws.send(msg.serialize());
	  };
	
	  Session.prototype.solve_all = function(metabook_model, event) {
	    var cells, ids, links, msg;
	    cells = imports.data.get_cells(metabook_model);
	    links = imports.data.get_links(metabook_model);
	    ids = imports.data.get_ids(cells);
	    msg = new Message({
	      session: this.id,
	      msg_type: "solve",
	      content: {
	        cells: cells,
	        links: links,
	        ids: ids
	      }
	    });
	    this.ws.send(msg.serialize());
	    return console.log("solve_all: " + this.id);
	  };
	
	  Session.prototype.onmessage = function(evt) {
	    return console.log(JSON.parse(evt.data));
	  };
	
	  Session.prototype.onclose = function(evt) {
	    console.log("<session:closed>");
	    return Backbone.trigger('session:closed', this);
	  };
	
	  Session.prototype.custom_events = {
	    'run': Session.prototype.run_cell
	  };
	
	  return Session;
	
	})();
	
	Message = (function() {
	  function Message(arg) {
	    var msg_type, session;
	    session = arg.session, msg_type = arg.msg_type, this.header = arg.header, this.parent_header = arg.parent_header, this.metadata = arg.metadata, this.content = arg.content;
	    if (this.header == null) {
	      this.header = this.defaults.header();
	    }
	    this.header.session = session;
	    this.header.msg_type = msg_type;
	    if (this.metadata == null) {
	      this.metadata = this.defaults.metadata;
	    }
	    if (this.parent_header == null) {
	      this.parent_header = this.defaults.parent_header;
	    }
	    if (this.content == null) {
	      this.content = this.defaults.content;
	    }
	  }
	
	  Message.prototype.defaults = {
	    header: function() {
	      return {
	        msg_id: joint.util.uuid(),
	        username: "default",
	        session: "",
	        date: "",
	        msg_type: "default",
	        version: '1'
	      };
	    },
	    metadata: {},
	    parent_header: {},
	    content: {}
	  };
	
	  Message.prototype.serialize = function() {
	    return JSON.stringify(this);
	  };
	
	  return Message;
	
	})();
	
	module.exports = {
	  Session: Session,
	  Message: Message
	};
	
	//# sourceMappingURL=connect.js.map


/***/ },
/* 4 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0
	module.exports = {
	  get_template: function(success, error) {
	    return $.ajax({
	      url: config.template_endpoint + config.file.path,
	      type: 'GET',
	      success: success,
	      error: error
	    });
	  },
	  get_file: function(success, error) {
	    return $.ajax({
	      url: config.file.endpoint + config.file.path,
	      type: 'GET',
	      success: success,
	      error: error
	    });
	  },
	  get_ajax_data: function(data_uri, success, error) {
	    return $.ajax({
	      url: data_uri,
	      type: 'GET',
	      success: success,
	      error: error
	    });
	  },
	  get_xhr: function(data_uri) {
	    return $.ajax({
	      url: data_uri,
	      type: 'GET'
	    });
	  },
	  is_good_form: function(json_data) {
	    if (typeof json_data === 'object') {
	      if ('metadata' in json_data) {
	        if ('metabook' in json_data.metadata) {
	          if ('links' in json_data.metadata.metabook) {
	            return true;
	          }
	        }
	      }
	    }
	    return false;
	  },
	  is_native: function(file_json) {
	    if ('metadata' in file_json) {
	      if (file_json.metadata.format === "native") {
	        return true;
	      }
	    }
	    return false;
	  },
	  get_cells: function(metabook_model) {
	    return metabook_model.get('cells').models;
	  },
	  get_ids: function(cells) {
	    var cell, i, ids, len;
	    ids = [];
	    for (i = 0, len = cells.length; i < len; i++) {
	      cell = cells[i];
	      ids.push(cell.id);
	    }
	    return ids;
	  },
	  get_links: function(metabook_model) {
	    return metabook_model.get('links').models;
	  }
	};
	
	//# sourceMappingURL=data.js.map


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.10.0
	(function(global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof module !== 'undefined' && module.exports) {
	    module.exports = factory();
	  } else {
	    global.ReconnectingWebSocket = factory();
	  }
	})(this, function() {
	  var ReconnectingWebSocket;
	  ReconnectingWebSocket = function(url, protocols, options) {
	    var eventTarget, forcedClose, generateEvent, key, self, settings, timedOut, ws;
	    settings = {
	      debug: false,
	      automaticOpen: true,
	      reconnectInterval: 1000,
	      maxReconnectInterval: 30000,
	      reconnectDecay: 1.5,
	      timeoutInterval: 2000,
	      maxReconnectAttempts: null,
	      binaryType: 'blob'
	    };
	
	    /**
	     * This function generates an event that is compatible with standard
	     * compliant browsers and IE9 - IE11
	     *
	     * This will prevent the error:
	     * Object doesn't support this action
	     *
	     * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563
	     * @param s String The name that the event should use
	     * @param args Object an optional object that the event will use
	     */
	    generateEvent = function(s, args) {
	      var evt;
	      evt = document.createEvent('CustomEvent');
	      evt.initCustomEvent(s, false, false, args);
	      return evt;
	    };
	    if (!options) {
	      options = {};
	    }
	    for (key in settings) {
	      if (typeof options[key] !== 'undefined') {
	        this[key] = options[key];
	      } else {
	        this[key] = settings[key];
	      }
	    }
	
	    /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */
	    this.url = url;
	
	    /** The number of attempted reconnects since starting, or the last successful connection. Read only. */
	    this.reconnectAttempts = 0;
	
	    /**
	     * The current state of the connection.
	     * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED
	     * Read only.
	     */
	    this.readyState = WebSocket.CONNECTING;
	
	    /**
	     * A string indicating the name of the sub-protocol the server selected; this will be one of
	     * the strings specified in the protocols parameter when creating the WebSocket object.
	     * Read only.
	     */
	    this.protocol = null;
	    self = this;
	    ws = void 0;
	    forcedClose = false;
	    timedOut = false;
	    eventTarget = document.createElement('div');
	    eventTarget.addEventListener('open', function(event) {
	      self.onopen(event);
	    });
	    eventTarget.addEventListener('close', function(event) {
	      self.onclose(event);
	    });
	    eventTarget.addEventListener('connecting', function(event) {
	      self.onconnecting(event);
	    });
	    eventTarget.addEventListener('message', function(event) {
	      self.onmessage(event);
	    });
	    eventTarget.addEventListener('error', function(event) {
	      self.onerror(event);
	    });
	    this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
	    this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
	    this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);
	    this.open = function(reconnectAttempt) {
	      var localWs, timeout;
	      ws = new WebSocket(self.url, protocols || []);
	      ws.binaryType = this.binaryType;
	      if (reconnectAttempt) {
	        if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {
	          return;
	        }
	      } else {
	        eventTarget.dispatchEvent(generateEvent('connecting'));
	        this.reconnectAttempts = 0;
	      }
	      Backbone.trigger("session:connecting", this);
	      console.log("<session:connecting>");
	      if (self.debug || ReconnectingWebSocket.debugAll) {
	        console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);
	      }
	      localWs = ws;
	      timeout = setTimeout((function() {
	        if (self.debug || ReconnectingWebSocket.debugAll) {
	          console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);
	        }
	        timedOut = true;
	        localWs.close();
	        timedOut = false;
	      }), self.timeoutInterval);
	      ws.onopen = function(event) {
	        var e;
	        clearTimeout(timeout);
	        if (self.debug || ReconnectingWebSocket.debugAll) {
	          console.debug('ReconnectingWebSocket', 'onopen', self.url);
	        }
	        self.protocol = ws.protocol;
	        self.readyState = WebSocket.OPEN;
	        self.reconnectAttempts = 0;
	        e = generateEvent('open');
	        e.isReconnect = reconnectAttempt;
	        reconnectAttempt = false;
	        eventTarget.dispatchEvent(e);
	      };
	      ws.onclose = function(event) {
	        var timeout;
	        var e;
	        clearTimeout(timeout);
	        ws = null;
	        if (forcedClose) {
	          self.readyState = WebSocket.CLOSED;
	          eventTarget.dispatchEvent(generateEvent('close'));
	        } else {
	          self.readyState = WebSocket.CONNECTING;
	          e = generateEvent('connecting');
	          e.code = event.code;
	          e.reason = event.reason;
	          e.wasClean = event.wasClean;
	          eventTarget.dispatchEvent(e);
	          if (!reconnectAttempt && !timedOut) {
	            if (self.debug || ReconnectingWebSocket.debugAll) {
	              console.debug('ReconnectingWebSocket', 'onclose', self.url);
	            }
	            eventTarget.dispatchEvent(generateEvent('close'));
	          }
	          timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
	          console.log("<session:waiting> " + (timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout));
	          Backbone.trigger("session:waiting", this, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);
	          setTimeout((function() {
	            self.reconnectAttempts++;
	            self.open(true);
	          }), timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);
	        }
	      };
	      ws.onmessage = function(event) {
	        var e;
	        if (self.debug || ReconnectingWebSocket.debugAll) {
	          console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);
	        }
	        e = generateEvent('message');
	        e.data = event.data;
	        eventTarget.dispatchEvent(e);
	      };
	      ws.onerror = function(event) {
	        if (self.debug || ReconnectingWebSocket.debugAll) {
	          console.debug('ReconnectingWebSocket', 'onerror', self.url, event);
	        }
	        eventTarget.dispatchEvent(generateEvent('error'));
	        Backbone.trigger("connection:error", this);
	        console.log("<session:error>");
	      };
	    };
	    if (this.automaticOpen === true) {
	      this.open(false);
	    }
	
	    /**
	     * Transmits data to the server over the WebSocket connection.
	     *
	     * @param data a text string, ArrayBuffer or Blob to send to the server.
	     */
	    this.send = function(data) {
	      if (ws) {
	        if (self.debug || ReconnectingWebSocket.debugAll) {
	          console.debug('ReconnectingWebSocket', 'send', self.url, data);
	        }
	        return ws.send(data);
	      } else {
	        throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';
	      }
	    };
	
	    /**
	     * Closes the WebSocket connection or connection attempt, if any.
	     * If the connection is already CLOSED, this method does nothing.
	     */
	    this.close = function(code, reason) {
	      if (typeof code === 'undefined') {
	        code = 1000;
	      }
	      forcedClose = true;
	      if (ws) {
	        ws.close(code, reason);
	      }
	    };
	
	    /**
	     * Additional public API method to refresh the connection if still open (close, re-open).
	     * For example, if the app suspects bad data / missed heart beats, it can try to refresh.
	     */
	    this.refresh = function() {
	      if (ws) {
	        ws.close();
	      }
	    };
	  };
	  if (!('WebSocket' in window)) {
	    return;
	  }
	
	  /**
	   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
	   * this indicates that the connection is ready to send and receive data.
	   */
	  ReconnectingWebSocket.prototype.onopen = function(event) {};
	
	  /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */
	  ReconnectingWebSocket.prototype.onclose = function(event) {};
	
	  /** An event listener to be called when a connection begins being attempted. */
	  ReconnectingWebSocket.prototype.onconnecting = function(event) {};
	
	  /** An event listener to be called when a message is received from the server. */
	  ReconnectingWebSocket.prototype.onmessage = function(event) {};
	
	  /** An event listener to be called when an error occurs. */
	  ReconnectingWebSocket.prototype.onerror = function(event) {};
	
	  /**
	   * Whether all instances of ReconnectingWebSocket should log debug messages.
	   * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
	   */
	  ReconnectingWebSocket.debugAll = false;
	  ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
	  ReconnectingWebSocket.OPEN = WebSocket.OPEN;
	  ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
	  ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;
	  return ReconnectingWebSocket;
	});
	
	//# sourceMappingURL=websocket.js.map


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	var SessionDisconnectedMessage,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	SessionDisconnectedMessage = (function(superClass) {
	  extend(SessionDisconnectedMessage, superClass);
	
	  function SessionDisconnectedMessage() {
	    this.render = bind(this.render, this);
	    this.hide = bind(this.hide, this);
	    this.show = bind(this.show, this);
	    return SessionDisconnectedMessage.__super__.constructor.apply(this, arguments);
	  }
	
	  SessionDisconnectedMessage.prototype.initialize = function() {
	    var templates;
	    SessionDisconnectedMessage.__super__.initialize.apply(this, arguments);
	    templates = __webpack_require__(7);
	    this.template = templates.Messages.SessionDisconnected;
	    return this.render();
	  };
	
	  SessionDisconnectedMessage.prototype.show = function() {
	    return this.$el.find(".message").removeClass("hidden");
	  };
	
	  SessionDisconnectedMessage.prototype.hide = function() {
	    return this.$el.find(".message").addClass("hidden");
	  };
	
	  SessionDisconnectedMessage.prototype.render = function() {
	    return this.$el.html(this.template);
	  };
	
	  return SessionDisconnectedMessage;
	
	})(Backbone.View);
	
	module.exports = {
	  SessionDisconnectedMessage: SessionDisconnectedMessage
	};
	
	//# sourceMappingURL=ui_messages.js.map


/***/ },
/* 7 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0
	module.exports = {
	  Messages: {
	    SessionDisconnected: '<div class="ui yellow message hidden" style="position:fixed; top:70px; left: 50%; transform: translateX(-50%);"> <div class="header"> Kernel disconnected </div> <p>Kernel is disconnected, trying to connect in XX seconds...</p></div>'
	  }
	};
	
	//# sourceMappingURL=templates.js.map


/***/ }
/******/ ]);
//# sourceMappingURL=metabook.js.map