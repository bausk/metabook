// Generated by CoffeeScript 1.10.0
var GraphPaper;

joint.shapes.html = {};

GraphPaper = joint.dia.Paper.extend({
  origin: {
    x: 0,
    y: 0
  },
  current_scale: 1,
  draggable: false,
  dragpoint: {
    x: 0,
    y: 0,
    offset_x: 0,
    offset_y: 0
  },
  initialize: function() {
    joint.dia.Paper.prototype.initialize.apply(this, arguments);
    _.bindAll(this, 'offsetToLocalPoint', 'updateOrigin', 'updateScale', 'getRealCoords');
    this.updateOrigin();
    this.updateScale();
    $(window).resize(_.bind((function() {
      return this.setDimensions(this.$el.width(), this.$el.height());
    }), this));
    this.on('cell:pointerdown cell:mouseover', function(cellView, evt, x, y) {
      if ($(evt.target).parent().hasClass("link")) {
        return cellView.options.interactive = false;
      }
    });
    this.on('all', function(evt, x, y) {
      return console.log(evt);
    });
    this.on('blank:pointerdown', function(evt, x, y) {
      evt = evt.originalEvent;
      if (evt.which !== 2) {
        return;
      }
      this.dragpoint.x = evt.pageX;
      this.dragpoint.y = evt.pageY;
      this.dragpoint.offset_x = this.origin.x * this.current_scale;
      this.dragpoint.offset_y = this.origin.y * this.current_scale;
      return this.draggable = true;
    });
    this.$el.on("mousewheel", _.bind((function(ev) {
      var coord1, coord2, delta, elem, i, len, newScale, p, results;
      ev.preventDefault();
      ev = ev.originalEvent;
      coord1 = ev.offsetX;
      coord2 = ev.offsetY;
      delta = 1.2;
      p = this.offsetToLocalPoint(coord1, coord2);
      if (ev.wheelDelta < 0) {
        newScale = this.current_scale / delta;
      } else {
        newScale = this.current_scale * delta;
      }
      if (newScale > 0.1 && newScale < 10) {
        this.scale(newScale, newScale);
        this.setOrigin(coord1 - newScale * p.x, coord2 - newScale * p.y);
        this.updateScale();
        this.updateOrigin();
        results = [];
        for (i = 0, len = custom_shapes.length; i < len; i++) {
          elem = custom_shapes[i];
          results.push(elem.updateBox());
        }
        return results;
      }
    }), this));
    this.$el.on("mousemove", _.bind((function(e) {
      var elem, i, len, results;
      if (this.draggable) {
        this.setOrigin(-this.dragpoint.offset_x + e.pageX - this.dragpoint.x, -this.dragpoint.offset_y + e.pageY - this.dragpoint.y);
        this.updateOrigin();
        results = [];
        for (i = 0, len = custom_shapes.length; i < len; i++) {
          elem = custom_shapes[i];
          results.push(elem.updateBox());
        }
        return results;
      }
    }), this));
    $(window).on('mouseup', function(e) {
      return this.draggable = false;
    });
    return this.on('blank:pointerup', function(cellView, event) {
      return this.draggable = false;
    });
  },
  offsetToLocalPoint: function(offsetX, offsetY) {
    var svgPoint;
    svgPoint = this.svg.createSVGPoint();
    svgPoint.x = offsetX;
    svgPoint.y = offsetY;
    return svgPoint.matrixTransform(this.viewport.getCTM().inverse());
  },
  updateScale: function() {
    return this.current_scale = V(this.viewport).scale().sx;
  },
  updateOrigin: function() {
    return this.origin = this.svg.createSVGPoint().matrixTransform(this.viewport.getCTM().inverse());
  },
  getRealCoords: function(modelX, modelY) {
    var offset, x, y;
    offset = this.origin;
    x = (modelX - offset.x) * this.current_scale;
    y = (modelY - offset.y) * this.current_scale;
    $(Settings.id.coords).text(modelX + ":" + modelY + "/" + x + ":" + y);
    return {
      x: x,
      y: y
    };
  },
  getModelCoords: function(pageX, pageY) {
    var offset, x, y;
    offset = this.origin;
    x = pageX / this.current_scale + offset.x;
    y = pageY / this.current_scale + offset.y;
    return {
      x: x,
      y: y
    };
  }
});

joint.shapes.html.Element = joint.shapes.basic.Rect.extend({
  defaults: joint.util.deepSupplement({
    type: 'html.Element',
    attrs: {
      rect: {
        stroke: 'none',
        'fill-opacity': 0
      }
    }
  }, joint.shapes.basic.Rect.prototype.defaults)
});

joint.shapes.html.ElementView = joint.dia.ElementView.extend({
  template: ['<div style="position:absolute">', '<table class="ui table">', '<button class="ui delete button">x</button>', '<label class="ui label"></label>', '<span></span>', '<br/>', '<select><option>--</option><option>one</option><option>two</option></select>', '<input type="text" value="I\'m HTML input" />', '</table>', '</div>'].join(''),
  initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.isdraggable = false;
    this.dragpoint = {
      x: 0,
      y: 0,
      paper_x: 0,
      paper_y: 0,
      client_x: 0,
      client_y: 0,
      offset_x: 0,
      offset_y: 0
    };
    this.$box = $(_.template(this.template)());
    this.$box.find('label').on('mousedown', _.bind((function(evt) {
      var point, point2;
      evt = evt.originalEvent;
      if (evt.which !== 1) {
        return;
      }
      this.dragpoint.x = evt.pageX;
      this.dragpoint.y = evt.pageY;
      point = this.paper.svg.createSVGPoint().matrixTransform(this.paper.viewport.getCTM().inverse());
      this.dragpoint.offset_x = point.x * V(this.paper.viewport).scale().sx;
      this.dragpoint.offset_y = point.y * V(this.paper.viewport).scale().sy;
      point2 = this.paper.offsetToLocalPoint(this.dragpoint.x, this.dragpoint.y);
      this.dragpoint.paper_x = point2.x;
      this.dragpoint.paper_y = point2.y;
      this.dragpoint.client_x = this.model.get('position').x;
      this.dragpoint.client_y = this.model.get('position').y;
      return this.isdraggable = true;
    }), this));
    $(window).on('mousemove', _.bind((function(evt) {
      var point;
      if (this.isdraggable) {
        if (evt.buttons !== 1) {
          this.isdraggable = false;
          return;
        }
        evt = evt.originalEvent;
        point = this.paper.offsetToLocalPoint(evt.pageX, evt.pageY);
        return this.model.set('position', {
          x: this.dragpoint.client_x - this.dragpoint.paper_x + point.x,
          y: this.dragpoint.client_y - this.dragpoint.paper_y + point.y
        });
      }

      /*
      evt = evt.originalEvent
      return if evt.which != 1
      @dragpoint.x = evt.pageX
      @dragpoint.y = evt.pageY
      point = Obj.mainpaper.svg.createSVGPoint().matrixTransform(Obj.mainpaper.viewport.getCTM().inverse())
      @dragpoint.offset_x = point.x * V(paper.viewport).scale().sx
      @dragpoint.offset_y = point.y * V(paper.viewport).scale().sy
      @paper_isdraggable = true
      #@model.set 'position', { x: 370, y: 300}
       */
    }), this));
    $(window).on('mouseup', _.bind((function(e) {
      return this.isdraggable = false;
    }), this));
    this.$box.find('input,select').on('mousedown click', function(evt) {
      return evt.stopPropagation();
    });
    this.$box.find('input').on('change', _.bind((function(evt) {
      this.model.set('input', $(evt.target).val());
    }), this));
    this.$box.find('select').on('change', _.bind((function(evt) {
      return this.model.set('select', $(evt.target).val());
    }), this));
    this.$box.find('select').val(this.model.get('select'));
    this.$box.find('.delete').on('click', _.bind(this.model.remove, this.model));
    this.model.on('change', this.updateBox, this);
    this.model.on('remove', this.removeBox, this);
    return custom_shapes.push(this);
  },
  render: function() {
    joint.dia.ElementView.prototype.render.apply(this, arguments);
    this.paper.$el.prepend(this.$box);
    this.updateBox();
    return this;
  },
  updateBox: function() {
    var bbox, ref, scale, x, y;
    bbox = this.model.getBBox();
    ref = this.paper.getRealCoords(bbox.x, bbox.y), x = ref.x, y = ref.y;
    bbox.x = x;
    bbox.y = y;
    scale = this.paper.current_scale;
    $(Settings.id.messages).text(bbox.x + "//" + bbox.y);
    this.$box.find('label').text(this.model.get('label'));
    this.$box.find('span').text(this.model.get('select'));
    this.$box.css('transform-origin', 'left top');
    return this.$box.css({
      width: bbox.width,
      height: bbox.height,
      left: bbox.x,
      top: bbox.y,
      transform: 'rotate(' + (this.model.get('angle') || 0) + 'deg) scale(' + scale + ')'
    });
  },
  removeBox: function(evt) {
    return this.$box.remove();
  }
});

//# sourceMappingURL=elements.js.map
